class HtmlTable {

    constructor(id, columns) {
        this._id = id;
        this._columns = columns;

        /**
         * The table HtmlElement.
         */
        this._tableElement = this.createTable(id, columns);

        /**
         * The thead HtmlElement.
         */
        this._tableHead = this._tableElement.children[0];

        /**
         * The tbody HtmlElement.
         */
        this._tableBody = this._tableElement.children[1];

        /**
         * The outermost container created for this HtmlTable.
         */
        this._tableOuterContainer = this.createOuterContainer();

        /**
         * The innermost container created for this HtmlTable (directly surrounds the table element)
         */
        this._tableInnerContainer = this.createInnerContainer();


        this._tableOuterContainer.appendChild(this._tableInnerContainer);
        this._tableInnerContainer.appendChild(this._tableElement);

        /**
         * The callback that is reponsible for providing data (rows) to the HtmlTable when refresh() 
         * is called without a pagination stategy.
         */
        this._populator = undefined;

        /**
         * Whether or not the loading spinner is currently spinning.
         */
        this._spinning = false;

        /**
         * The spinner img HtmlElement.
         */
        this._spinner = undefined;

        /**
         * The storage for rows retrieved using eager pagination.
         */
        this._eagerPaginationRows = undefined;

        /**
         * The current page number when using pagination.
         */
        this._currentPage = 1;

        /**
         * The object containing information about the pagination configured in the HtmlTable.
         */
        this._paginationStrategy = undefined;

        /**
         * Whether or not the HtmlTable should generate pagination buttons when the table is refreshed.
         */
        this._usePaginationButtons = false;

        /**
         * The container generated by the table when using pagination buttons.
         */
        this._paginationButtonsContainer = undefined;
    }

    /**
     * Sets the message to write in the table body when there are no results.
     * 
     * Cannot contain html.
     */
    set noResultsMessage(message) {
        this._noResultsMessage = { html: false, message };
    }

    /**
     * Sets the message to write in the table body when there are no results.
     * 
     * Can containg html.
     */
    set noResultMessageHTML(message) {
        this._noResultsMessage = { html: true, message };
    }

    /**
      * Sets the callback that is reponsible for providing data (rows) to the HtmlTable when refresh() 
      * is called without a pagination stategy.
      */
    set populator(populator) {
        this._populator = populator;
    }

    /**
     * Retrieves the current page number (1 indexed).
     */
    get currentPage() {
        return this._currentPage;
    }

    /**
     * Returns the table HtmlElement.
     */
    get tableElement() {
        return this._tableElement;
    }

    /**
     * Returns the outermost container of this HtmlTable.
     */
    get tableContainer() {
        return this._tableOuterContainer;
    }

    /**
     * Sets the starting height of the body in pixels.
     */
    set startingHeight(startingHeight) {
        this._tableInnerContainer.style.minHeight = this.absoluteBoundingBox(this._tableHead).height + startingHeight + 'px';
    }

    /**
     * Appends the table to the provided element.
     * @param HtmlElemeent parent The element to append this table to. 
     */
    appendTo(parent) {
        parent.appendChild(this._tableOuterContainer);
    }

    /**
     * Sets the starting height of the body in pixels.
     */
    setStartingHeight(startingHeight) {
        this.startingHeight = startingHeight;
    }

    /**
     * Creates the outmost container of this HtmlTable.
     */
    createOuterContainer() {
        const div = document.createElement('div');
        div.classList.add('rest-table-outer-container');
        return div;
    }

    /**
     * Creates the innermost container of this HtmlTable.
     */
    createInnerContainer() {
        const div = document.createElement('div');
        div.classList.add('rest-table-inner-container');

        return div;
    }

    /**
     * Creates the table HtmlElement of this HtmlTable.
     * @param {*} id 
     * @param {*} columns 
     */
    createTable(id, columns) {
        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const tbody = document.createElement("tbody");

        table.id = id;
        table.appendChild(thead);
        table.appendChild(tbody);

        this.createTableHeaders(thead, columns);

        return table;
    }

    /**
     * Creates the th elements based on the provided columns. 
     * @param {*} thead The thead to place the generated th's into. 
     * @param {*} columns The array of objects describing the columns in the table.
     */
    createTableHeaders(thead, columns) {
        const tr = document.createElement('tr');
        columns.forEach(column => {
            const th = document.createElement('th');
            th.innerText = column['name'];
            if (column['class'] != undefined)
                th.classList.add(column['class']);
            tr.appendChild(th);
        });
        thead.appendChild(tr);
    }

    /**
     * Instructs the HtmlTable to use eager pagination. All rows are retrieved when refhresed, but only single pages 
     * of the provided size is shown.
     * @param {*} pageSize The number of results on pages.
     */
    useEagerPagination(pageSize) {
        this._paginationStrategy = { mode: 'eager', pageSize };
    }

    /**
     * Instructs the HtmlTable to use lazy loading for pagination.
     * 
     * @param pageSize The number of pages the table is configured to hold.
     * @param dataCallback The callback that retrieves the data (rows) for a new page.
     * @param countCallback The callback that retrieves the number of rows in total.
     */
    useLazyPagination(pageSize, dataCallback, countCallback) {
        this._paginationStrategy = { mode: 'lazy', pageSize, dataCallback, countCallback };
    }

    /**
     * Instructs the HtmlTable to automatically generate pagination buttons.
     */
    usePaginationButtons() {

        if (this._paginationStrategy == undefined) {
            throw new Error("No pagination configured.");
        }

        this._usePaginationButtons = true;
        if (this._paginationStrategy['mode'] == 'lazy')
            this._paginationStrategy['countCallback'](count => {
                this.createPaginationButtons(count);
            });
    }

    /**
     * Removes the existing pagination buttons.
     */
    removePaginationButtons() {
        if (this._paginationButtonsContainer != undefined) {
            this._tableOuterContainer.removeChild(this._paginationButtonsContainer);
            this._paginationButtonsContainer = undefined;
        }
    }

    /**
     * Creates pagination buttons for this HtmlTable.
     * @param {*} count The number of rows to generate pagination buttons for.
     */
    createPaginationButtons(count) {

        this.removePaginationButtons();

        const container = document.createElement('div');
        container.classList.add('rest-table-pagination');
        const ul = document.createElement('ul');
        ul.classList.add('pagination');
        const numberOfPages = Math.ceil(count / this._paginationStrategy.pageSize);
        let activeLi = undefined;
        for (let i = 1; i <= numberOfPages; i++) {
            const li = document.createElement('li');
            li.classList.add('waves-effect');
            const a = document.createElement('a');
            a.innerText = "" + i;
            li.appendChild(a);

            if (i == 1) {
                activeLi = li;
                li.classList.add('active');
            }

            li.addEventListener('click', e => {
                this.page(i);
                li.classList.add('active');
                activeLi.classList.remove('active');
                activeLi = li;
            });
            ul.appendChild(li);
        }

        container.appendChild(ul);
        this._tableOuterContainer.appendChild(container);
        this._paginationButtonsContainer = container;
    }

    /**
     * Clears the tbody of this HtmlTable.
     */
    clear() {
        this._tableBody.innerHTML = '';
    }

    /**
     * Loads the page with the provided page number.
     * @param Integer page The page to load, starts at 1.
     * @param boolean refresh Whether or not the data in the HtmlTable should be refreshed.
     */
    page(page, refresh = false) {

        if (this._paginationStrategy == undefined)
            throw new Error("No pagination config.");


        const paginationMode = this._paginationStrategy.mode;

        if (paginationMode == 'eager') {
            this.pageWithEagerPagination(page, refresh);
            return;
        }

        if (paginationMode == 'lazy') {
            this.pageWithLazyPagination(page, refresh);
            return;
        }

        throw new Error("Unknown pagination mode " + paginationMode);
    }

    /**
     * Loads the page with the provided page number using eager pagination. 
     * @param {*} page The page to load, starts at 1.
     * @param boolean refresh Whether or not the data in the HtmlTable should be reloaded.  
     */
    pageWithEagerPagination(page, refresh = false) {

        if (refresh) {
            this._populator(rows => {
                this._eagerPaginationRows = rows;

                // TODO: fix code repetition
                this.clear();
                const start = (page - 1) * this._paginationStrategy.pageSize;
                const end = start + this._paginationStrategy.pageSize;
                this.appendRows(this._eagerPaginationRows.slice(start, end));
                this._currentPage = page;
                if (refresh)
                    this.createPaginationButtons(rows.length);

                if (rows.length < 1)
                    this.showNoResultsMessage();
            });

            return;
        }

        // TODO: fix code repetition
        this.clear();
        const start = (page - 1) * this._paginationStrategy.pageSize;
        const end = start + this._paginationStrategy.pageSize;
        this.appendRows(this._eagerPaginationRows.slice(start, end));
        this._currentPage = page;
        if (refresh)
            this.createPaginationButtons(this._eagerPaginationRows.length);

        if (rows.length < 1)
            this.showNoResultsMessage();
    }

    /**
     * Loads the page with the provided page number using lazy pagination.
     * @param {*} page The page to load, starts at 1.
     * @param boolean refresh Whether or not the data in the HtmlTable should be reloaded. 
     */
    pageWithLazyPagination(page, refresh = false) {

        this.startLoadingAnimation();
        this._paginationStrategy.dataCallback(page, this._paginationStrategy.pageSize, rows => {
            this.clear();
            this.appendRows(rows);
            this.stopLoadingAnimation();
            this._currentPage = page;
            if (refresh)
                this._paginationStrategy.countCallback(count => this.createPaginationButtons(count));
        });
    }

    /**
     * Starts the animation(s) showing that the HtmlTable is currently refreshing.
     */
    startLoadingAnimation() {
        this.startSpinner();
        this.translucent();
        this._tableInnerContainer.classList.add('loading');
        this._tableOuterContainer.classList.add('loading');
    }

    /**
     * Stops the animation(s) showing that the HtmlTable is currently refreshing.
     */
    stopLoadingAnimation() {
        this.stopSpinner();
        this.opaque();
        this._tableInnerContainer.classList.remove('loading');
        this._tableOuterContainer.classList.remove('loading');
    }

    /**
     * Makes the tbody of the HtmlTable translucent.
     */
    translucent() {
        this._tableBody.style.opacity = 0.4;
    }

    /**
     * Makes the tbody of the HtmlTable opaque.
     */
    opaque() {
        this._tableBody.style.opacity = 1;
    }

    /**
     * Appends the provided rows to this HtmlTable.
     * @param object[] rows The rows to append.
     */
    appendRows(rows) {
        rows.forEach(row => this.appendRow(row));
    }


    /**
     * Appends the provided row to this HtmlTable.
     * @param object row The row to append. 
     */
    appendRow(row) {

        const tr = document.createElement('tr');

        this._columns.forEach(column => {
            const td = document.createElement('td');
            if (column['key'] != undefined)
                td.innerText = row[column['key']];
            else if (column['element'] != undefined)
                td.appendChild(column['element'](row));
            else if (column['text'] != undefined)
                td.innerText = column['text'](row);
            if (column['class'] != undefined)
                td.classList.add(column['class']);
            tr.appendChild(td);
        });

        this._tableBody.appendChild(tr);
    }

    /**
     * Appends the provided non-html message to this HtmlTable.
     * The message is inserted into the tbody, with a colspan equalling the number of columns in the table.
     * 
     * @param {*} message The message to append.
     */
    appendMessage(message) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.innerText = message;
        td.colSpan = this._columns.length;
        tr.appendChild(td);
        this._tableBody.appendChild(tr);
    }

    /**
     * Appends the provided html message to this HtmlTable.
     * The message is inserted into the tbody, with a colspan equalling the number of columns in the table.
     * 
     * @param {*} message The message to append.
     */
    appendHtmlMessage(message) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.innerHTML = message;
        td.colSpan = this._columns.length;
        tr.appendChild(td);
        this._tableBody.appendChild(tr);
    }

    /**
     * Starts the spinning animation showing that the HtmlTable is loading data.
     * @param {*} loaderWidth The width of the loading animation in pixels.
     * @param {*} loaderHeight The height of the loading animation in pixels.
     */
    startSpinner(loaderWidth = 64, loaderHeight = 64) {

        if (!this._spinning) {

            const bounding = this.absoluteBoundingBox(this._tableInnerContainer);
            this._spinner = document.createElement('img');
            this._spinner.src = 'loader.gif';
            this._spinner.style.top = 20 + bounding.top + (bounding.height - loaderHeight) / 2 + 'px';
            this._spinner.style.left = 20 + bounding.left + (bounding.width - loaderWidth) / 2 + 'px';
            this._spinner.style.position = 'absolute';
            this._spinner.height = loaderHeight;
            this._spinner.width = loaderWidth;
            this._tableOuterContainer.appendChild(this._spinner);
            this._spinning = true;
        }
    }

    /**
     * Stops the spinning animation showing that the HtmlTable is loading data.
     */
    stopSpinner() {
        if (this._spinning) {
            this._spinner.parentElement.removeChild(this._spinner);
            this._spinner = undefined;
            this._spinning = false;
        }
    }

    /**
     * Returns the bounding box of the provided element relative to the document (absolute).
     * @param {*} element The element to return the absolute bounding box of.
     */
    absoluteBoundingBox(element) {


        const bodyRect = document.body.getBoundingClientRect();
        const elemRect = element.getBoundingClientRect();

        let result = {
            height: elemRect.height,
            width: elemRect.width,
            left: elemRect.left,
            right: elemRect.right,
            top: elemRect.top - bodyRect.top,
            bottom: elemRect.bottom - bodyRect.bottom
        }

        return result;

    }

    /**
     * Causes the table to reload, when a pagination configuration is present, the current page is reloaded. 
     * When the pagination mode is eager, the data is once again retrieved using the defined populator.
     */
    refresh() {

        // No pagination config
        if (this._paginationStrategy == undefined) {
            if (this._populator == undefined)
                throw new Error("No populator defined when refresh was called.");
            this.startLoadingAnimation();
            this._populator(rows => {
                this.clear();
                this.appendRows(rows);
                this.stopLoadingAnimation();
                if (rows.length < 1)
                    this.showNoResultsMessage();
            });

            return;
        }

        this.page(this._currentPage, true);
    }

    /**
     * Causes the HtmlTable to display the message for when no results are available.
     */
    showNoResultsMessage() {
        if (this._noResultsMessage != null)
            if (this._noResultsMessage.html)
                this.appendHtmlMessage(this._noResultsMessage.message);
            else
                this.appendMessage(this._noResultsMessage.message);
    }
}

export default HtmlTable;